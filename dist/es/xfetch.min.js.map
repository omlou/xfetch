{"version":3,"file":"xfetch.min.js","sources":["../../src/classes.ts","../../src/xhrfetch.ts","../../src/main.ts"],"sourcesContent":["export interface XHRHeaders {\r\n  [Symbol.iterator]?(): IterableIterator<[string, string]>\r\n  append(name: string, value: string): void\r\n  delete(name: string): void\r\n  get(name: string): string | null\r\n  has(name: string): boolean\r\n  set(name: string, value: string): void\r\n  forEach(callback: (value: string, key: string, parent: Headers) => void, thisArg?: any): void\r\n  entries(): IterableIterator<[string, string]>\r\n  keys(): IterableIterator<string>\r\n  values(): IterableIterator<string>\r\n}\r\n\r\ninterface Hs {\r\n  [prop: string]: string\r\n}\r\nconst hs: Hs = {}\r\n\r\nexport function XHRHeaders() {}\r\n\r\nObject.assign(XHRHeaders.prototype, {\r\n  get(key: string): string | null {\r\n    let res: any = hs[key]\r\n    if (res === undefined) res = null\r\n    return res\r\n  },\r\n  set(key: string, value: string): void {\r\n    hs[key] = value\r\n  },\r\n  append(key: string, value: string): void {\r\n    let val = hs[key]\r\n    if (val === undefined) {\r\n      hs[key] = value\r\n    } else {\r\n      hs[key] = val + \", \" + value\r\n    }\r\n  },\r\n  delete(key: string): void {\r\n    delete hs[key]\r\n  },\r\n  has(key: string): boolean {\r\n    return Object.prototype.hasOwnProperty.call(hs, key)\r\n  },\r\n  keys(): IterableIterator<string> {\r\n    return Object.keys(hs)[Symbol.iterator]()\r\n  },\r\n  values(): IterableIterator<string> {\r\n    return (Object.values(hs) as string[])[Symbol.iterator]()\r\n  },\r\n  entries(): IterableIterator<[string, string]> {\r\n    const keys = Object.keys(hs)\r\n    const entries = keys.map((key) => [key, hs[key]])\r\n    return (entries as Array<[string, string]>)[Symbol.iterator]()\r\n  },\r\n  forEach(callback: (value: string, key: string, parent: any) => void, thisArg?: any) {\r\n    for (let key in hs) {\r\n      if (Object.prototype.hasOwnProperty.call(hs, key)) {\r\n        thisArg ? callback.call(thisArg, hs[key], key, hs) : callback(hs[key], key, hs)\r\n      }\r\n    }\r\n  }\r\n})\r\n\r\nif (Symbol && Symbol.iterator) {\r\n  XHRHeaders.prototype[Symbol.iterator] = function (): IterableIterator<[string, string]> {\r\n    const keys = Object.keys(hs)\r\n    const entries = keys.map((key) => [key, hs[key]])\r\n    return (entries as Array<[string, string]>)[Symbol.iterator]()\r\n  }\r\n}\r\n\r\nexport interface XHRFetchResponse {\r\n  readonly body: Blob | null\r\n  readonly bodyUsed: boolean\r\n  readonly headers: any\r\n  readonly ok: boolean\r\n  readonly redirected: boolean\r\n  readonly status: number\r\n  readonly statusText: string\r\n  readonly type: string\r\n  readonly url: string\r\n  clone(): XHRFetchResponse\r\n  arrayBuffer(): Promise<ArrayBuffer>\r\n  blob(): Promise<Blob>\r\n  formData(): Promise<FormData>\r\n  json(): Promise<any>\r\n  text(): Promise<string>\r\n}\r\n\r\nexport function XHRFetchResponse(\r\n  body: Blob,\r\n  bodyUsed: boolean,\r\n  headers: any,\r\n  ok: boolean,\r\n  redirected: boolean,\r\n  status: number,\r\n  statusText: string,\r\n  type: string,\r\n  url: string\r\n) {\r\n  this.body = body\r\n  this.bodyUsed = bodyUsed\r\n  this.headers = headers\r\n  this.ok = ok\r\n  this.redirected = redirected\r\n  this.status = status\r\n  this.statusText = statusText\r\n  this.type = type\r\n  this.url = url\r\n}\r\n\r\nObject.assign(XHRFetchResponse.prototype, {\r\n  async blob(): Promise<Blob> {\r\n    return this.body\r\n  },\r\n  async arrayBuffer(): Promise<ArrayBuffer> {\r\n    return this.body.arrayBuffer()\r\n  },\r\n  clone(): XHRFetchResponse {\r\n    return this\r\n  },\r\n  async formData(): Promise<FormData> {\r\n    const formData = new FormData()\r\n    const { type, data } = await readBlob(this.body)\r\n    switch (type) {\r\n      case \"text\": {\r\n        let json = null\r\n        try {\r\n          json = JSON.parse(data)\r\n          for (let key in json) {\r\n            if (Object.prototype.hasOwnProperty.call(json, key)) {\r\n              formData.append(key, json[key])\r\n            }\r\n          }\r\n          return formData\r\n        } catch (exc) {\r\n          throw \"Target cannot be converted to FormData.\"\r\n        }\r\n      }\r\n      default: {\r\n        formData.append(\"file\", data)\r\n        return formData\r\n      }\r\n    }\r\n  },\r\n  async json(): Promise<any> {\r\n    let json = null\r\n    const { type, data } = await readBlob(this.body)\r\n    if (type === \"text\") {\r\n      try {\r\n        json = JSON.parse(data)\r\n        return json\r\n      } catch (exc) {\r\n        throw \"Target is not json.\"\r\n      }\r\n    } else {\r\n      throw \"Target is not json.\"\r\n    }\r\n  },\r\n  async text(): Promise<any> {\r\n    const { data } = await readBlob(this.body, \"text/plain\")\r\n    return data\r\n  }\r\n})\r\n\r\nfunction readBlob(blob: Blob, type?: string): Promise<any> {\r\n  const fileType = type || blob.type\r\n  return new Promise((resolve, reject) => {\r\n    switch (fileType) {\r\n      case \"text/plain\":\r\n      case \"application/json\":\r\n      case \"\": {\r\n        const reader = new FileReader()\r\n        reader.onload = () => {\r\n          const text = reader.result as string\r\n          resolve({\r\n            type: \"text\",\r\n            data: text\r\n          })\r\n        }\r\n        reader.onerror = (error) => {\r\n          reject(error)\r\n        }\r\n        reader.readAsText(blob)\r\n        break\r\n      }\r\n      default: {\r\n        resolve({\r\n          type: \"file\",\r\n          data: blob\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n","import { XHRFetchResponse, XHRHeaders } from './classes'\r\n\r\nfunction getHeaders(arg: string | null): any {\r\n  const headers: any = new (XHRHeaders as any)()\r\n  if (arg !== null) {\r\n    const arr = arg.trim().split(/[\\r\\n]+/)\r\n    for (const item of arr) {\r\n      const parts = item.split(': ')\r\n      headers.append(parts[0], parts[1])\r\n    }\r\n  }\r\n  return headers\r\n}\r\n\r\nfunction getOk(status: number): boolean {\r\n  return status >= 200 && status <= 299\r\n}\r\n\r\nfunction getType(xhr: XMLHttpRequest): string {\r\n  const res = /^https?:\\/\\/[\\w-.]+(:\\d+)?/i.exec(xhr.responseURL)\r\n  const origin = res ? res[0] : null\r\n  const type = (origin === window.location.origin) ? \"basic\" : \"cors\"\r\n  return type\r\n}\r\n\r\nexport function xhrFetch(input: RequestInfo | URL, init?: RequestInit | undefined): Promise<XHRFetchResponse> {\r\n  return new Promise(function(resolve, reject) {\r\n    const xhr = new XMLHttpRequest()\r\n    xhr.addEventListener('load', ev => {\r\n      console.log(\"load\", ev, xhr)\r\n      const headers = xhr.getAllResponseHeaders()\r\n      const res = new (XHRFetchResponse as any)(xhr.response, false, getHeaders(headers), getOk(xhr.status), false, xhr.status, xhr.statusText, getType(xhr), xhr.responseURL)\r\n      resolve(res)\r\n    })\r\n    xhr.addEventListener('error', ev => {\r\n      console.log(\"error\", ev, xhr)\r\n      reject(\"TypeError: Failed to fetch\")\r\n    })\r\n    xhr.addEventListener('timeout', ev => {\r\n      console.log(\"timeout\", ev, xhr)\r\n      reject(\"TypeError: Failed to fetch\")\r\n    })\r\n    let method = \"GET\"\r\n    if (init) {\r\n      method = (init.method?.toUpperCase() || \"GET\")\r\n    }\r\n    let simrequ = false\r\n    if (new Set(['GET', 'DELETE', 'HEAD', 'OPTIONS', 'TRACE']).has(method)) simrequ = true\r\n    if (input instanceof Request) input = input.url\r\n    xhr.open(method, input, true)\r\n    xhr.responseType = \"blob\"\r\n    if (init) {\r\n      if (init.credentials && init.credentials === \"include\") {\r\n        xhr.withCredentials = true\r\n      }\r\n      const { headers } = init\r\n      if (headers) {\r\n        if (Array.isArray(headers)) {\r\n          for (const item of headers) {\r\n            xhr.setRequestHeader(item[0], item[1])\r\n          }\r\n        } else if (headers instanceof Headers) {\r\n          headers.forEach((item, i) => {\r\n            xhr.setRequestHeader(i, item)\r\n          })\r\n        } else {\r\n          for (const i in headers) {\r\n            xhr.setRequestHeader(i, headers[i])\r\n          }\r\n        }\r\n      }\r\n    }\r\n    let body = null\r\n    if (init) {\r\n      body = (init.body || null)\r\n    }\r\n    if (body instanceof ReadableStream) throw \"Body does not support ReadableStream in XMLHttpRequest.\"\r\n    xhr.send(body)\r\n  })\r\n}","import { xhrFetch } from './xhrfetch'\r\n\r\nexport type PropType = string | number | symbol\r\n\r\ntype ValueType = string | number | symbol | boolean | null | undefined\r\n\r\ninterface SimpleParams {\r\n  [prop: PropType]: ValueType\r\n}\r\n\r\ninterface SimpleObject {\r\n  [prop: string]: ValueType\r\n}\r\n\r\nexport type XFContentType = \"json\" | \"urlencoded\" | \"formData\" | \"text\" | \"xml\" | \"stream\"\r\n\r\nexport type XFResponseType = \"json\" | \"text\" | \"blob\" | \"arrayBuffer\" | \"formData\"\r\n\r\nconst contentTypeObj: { [prop: string]: string } = {\r\n  json: \"application/json;charset=UTF-8\",\r\n  urlencoded: \"application/x-www-form-urlencoded;charset=UTF-8\",\r\n  formData: \"multipart/form-data\",\r\n  text: \"text/plain;charset=UTF-8\",\r\n  xml: \"application/xml;charset=UTF-8\",\r\n  stream: \"application/octet-stream\"\r\n}\r\n\r\nexport interface XfetchInit extends RequestInit {\r\n  query?: SimpleParams\r\n  data?: BodyInit | null | SimpleParams\r\n  contentType?: XFContentType\r\n  responseType?: XFResponseType\r\n}\r\n\r\nexport interface XfetchResponse extends Response {\r\n  jsonSync?: string\r\n  textSync?: string\r\n  blobSync?: Blob\r\n  arrayBufferSync?: ArrayBuffer\r\n  formDataSync?: FormData\r\n}\r\n\r\nfunction getFetch(): Function {\r\n  if (!window.fetch) {\r\n    window.fetch = xhrFetch\r\n  }\r\n  return window.fetch\r\n}\r\n\r\nexport function queryString(obj: SimpleObject, bol: boolean = false) {\r\n  const arr = []\r\n  for (const i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      if (obj[i] === null || obj[i] === undefined) {\r\n        obj[i] = \"\"\r\n      } else {\r\n        obj[i] = String(obj[i])\r\n      }\r\n      arr.push(encodeURIComponent(i) + '=' + encodeURIComponent(obj[i] as string))\r\n    }\r\n  }\r\n  const str = arr.join('&')\r\n  return (str && bol) ? (\"?\" + str) : str\r\n}\r\n\r\nfunction getHref(url: string, querystr: string): string {\r\n  let index = url.indexOf(\"#\")\r\n  let href = \"\"\r\n  let hash = \"\"\r\n  if (index === -1) {\r\n    href = url\r\n  } else {\r\n    href = url.substring(0, index)\r\n    hash = url.substring(index)\r\n  }\r\n  href += href.includes(\"?\") ? (\"&\" + querystr) : (\"?\" + querystr)\r\n  return href + hash\r\n}\r\n\r\nfunction getContentType(headers: HeadersInit | undefined): string | null {\r\n  if (!headers) return null\r\n  if (Array.isArray(headers)) {\r\n    for (let item of headers) {\r\n      if(item[0].toLowerCase() === \"content-type\") return item[1]\r\n    }\r\n    return null\r\n  }\r\n  if (headers instanceof Headers) {\r\n    return headers.get(\"content-type\")\r\n  }\r\n  for (const i in headers) {\r\n    if (Object.prototype.hasOwnProperty.call(headers, i)) {\r\n      const l = i.toLowerCase()\r\n      if (l === \"content-type\") return headers[i]\r\n    }\r\n  }\r\n  return null\r\n}\r\n\r\nfunction setContentType(headers: HeadersInit, value: string) {\r\n  if (Array.isArray(headers)) {\r\n    headers.push([\"Content-Type\", value])\r\n  } else if (headers instanceof Headers) {\r\n    headers.set(\"Content-Type\", value)\r\n  } else {\r\n    headers[\"Content-Type\"] = value\r\n  }\r\n}\r\n\r\nexport function xfetch(input: RequestInfo | URL, init?: XfetchInit | undefined): Promise<XfetchResponse> {\r\n  const finalFetch = getFetch()\r\n  /* if no init */\r\n  if (!init) return finalFetch(input)\r\n  /* handling the 'init' parameter */\r\n  const { query, data, contentType, responseType } =  (init as any)\r\n  /* handling the 'query' */\r\n  if (!(input instanceof Request) && query) {\r\n    const querystr = queryString(query)\r\n    if (querystr) {\r\n      if (typeof input === \"string\") {\r\n        input = getHref(input, querystr)\r\n      } else {\r\n        input = new URL(getHref(input.href, querystr))\r\n      }\r\n    }\r\n  }\r\n  /* handling the 'contentType' */\r\n  let { headers } = init\r\n  if (contentType) {\r\n    if (!headers) {\r\n      init.headers = {\r\n        \"Content-Type\": contentTypeObj[contentType]\r\n      }\r\n    } else if (!getContentType(headers)) {\r\n      setContentType(headers, contentTypeObj[contentType])\r\n    }\r\n  }\r\n  /* handling the 'data' */\r\n  const { body } = init\r\n  headers = init.headers\r\n  if (data) {\r\n    if (!body) {\r\n      const ctype: any = getContentType(headers)\r\n      let res = data\r\n      if (!(typeof data === \"string\")) {\r\n        if (ctype) {\r\n          if (ctype.includes(\"application/json\")) {\r\n            try {\r\n              res = JSON.stringify(data)\r\n            } catch (exc) {\r\n              console.warn(\"Failed to convert \\\"data\\\" to JSON string.\")\r\n            }\r\n          } else if (ctype.includes(\"application/x-www-form-urlencoded\")) {\r\n            try {\r\n              res = queryString(data)\r\n            } catch (exc) {\r\n              console.warn(\"Failed to convert \\\"data\\\" to urlencoded string.\")\r\n            }\r\n          } else if (ctype.includes(\"multipart/form-data\") && !(data instanceof FormData)) {\r\n            try {\r\n              const formData = new FormData()\r\n              for (const i in data) {\r\n                if (Object.prototype.hasOwnProperty.call(data, i)) {\r\n                  formData.append(i, data[i])\r\n                }\r\n              }\r\n              res = formData\r\n            } catch (exc) {\r\n              console.warn(\"Failed to convert \\\"data\\\" to FormData.\")\r\n            }\r\n          }\r\n        } else {\r\n          /* if 'data' can be converted to JSON string and 'Content-Type' is not specified, it defaults to JSON */\r\n          try {\r\n            res = JSON.stringify(data)\r\n            if (!headers) {\r\n              init.headers = {\r\n                \"Content-Type\": \"application/json;charset=UTF-8\"\r\n              }\r\n            } else {\r\n              setContentType(headers, \"application/json;charset=UTF-8\")\r\n            }\r\n          } catch (exc) { }\r\n        }\r\n      }\r\n      init.body = res\r\n    }\r\n  }\r\n  /* handling the 'responseType' */\r\n  if (!responseType) return finalFetch(input, init)\r\n  return new Promise(function (resolve, reject) {\r\n    finalFetch(input, init)\r\n      .then((response: any) => {\r\n        const response1 = response.clone()\r\n        response1[responseType]()\r\n          .then((res: string) => {\r\n            response[responseType + \"Sync\"] = res\r\n            resolve(response)\r\n          })\r\n          .catch(() => {\r\n            resolve(response)\r\n          })\r\n      })\r\n      .catch((exc: any) => {\r\n        reject(exc)\r\n      })\r\n  })\r\n}"],"names":["hs","XHRHeaders","XHRFetchResponse","body","bodyUsed","headers","ok","redirected","status","statusText","type","url","this","readBlob","blob","fileType","Promise","resolve","reject","reader","FileReader","onload","text","result","data","onerror","error","readAsText","xhrFetch","input","init","xhr","XMLHttpRequest","addEventListener","ev","console","log","getAllResponseHeaders","res","response","arg","arr","trim","split","item","parts","append","getHeaders","exec","responseURL","window","location","origin","getType","method","toUpperCase","Set","has","Request","open","responseType","credentials","withCredentials","Array","isArray","setRequestHeader","Headers","forEach","i","ReadableStream","send","Object","assign","prototype","get","key","undefined","set","value","val","delete","hasOwnProperty","call","keys","Symbol","iterator","values","entries","map","callback","thisArg","async","arrayBuffer","clone","formData","FormData","json","JSON","parse","exc","contentTypeObj","urlencoded","xml","stream","queryString","obj","bol","String","push","encodeURIComponent","str","join","getHref","querystr","index","indexOf","href","hash","substring","includes","getContentType","toLowerCase","setContentType","xfetch","finalFetch","fetch","query","contentType","URL","ctype","stringify","warn","then","catch"],"mappings":"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"}